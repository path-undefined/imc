export type TokenDefinition = {
  type: string;
  matcher: string | RegExp;
};

export const tokenDefinitions: TokenDefinition[] = [
  { type: "line_comment", matcher: /^\/\/.*(\r\n|\r|\n|$)/u },
  { type: "trash_character", matcher: /^[ \t\r\n]+/u },

  { type: "annotation_auto", matcher: "@auto" },
  { type: "annotation_register", matcher: "@register" },
  { type: "annotation_static", matcher: "@static" },
  { type: "annotation_extern", matcher: "@extern" },
  { type: "annotation_inline", matcher: "@inline" },
  { type: "annotation_thread_local", matcher: "@thread_local" },
  { type: "annotation_restrict", matcher: "@restrict" },
  { type: "annotation_volatile", matcher: "@volatile" },
  { type: "annotation_public", matcher: "@public" },
  { type: "annotation_private", matcher: "@private" },
  
  { type: "keyword_import", matcher: "import" },
  { type: "keyword_export", matcher: "export" },
  { type: "keyword_as", matcher: "as" },
  { type: "keyword_for", matcher: "for" },
  { type: "keyword_while", matcher: "while" },
  { type: "keyword_break", matcher: "break" },
  { type: "keyword_continue", matcher: "continue" },
  { type: "keyword_if", matcher: "if" },
  { type: "keyword_elseif", matcher: "elseif" },
  { type: "keyword_else", matcher: "else" },
  { type: "keyword_const", matcher: "const" },
  { type: "keyword_var", matcher: "var" },
  { type: "keyword_enum", matcher: "enum" },
  { type: "keyword_struct", matcher: "struct" },
  { type: "keyword_union", matcher: "union" },
  { type: "keyword_fn", matcher: "fn" },
  { type: "keyword_return", matcher: "return" },
  { type: "keyword_type", matcher: "type" },
  { type: "keyword_alignas", matcher: "alignas" },
  { type: "keyword_alignof", matcher: "alignof" },
  { type: "keyword_sizeof", matcher: "sizeof" },

  { type: "symbol_&", matcher: "&"},
  { type: "symbol_*", matcher: "*"},
  { type: "symbol_@", matcher: "@"},
  { type: "symbol_(", matcher: "(" },
  { type: "symbol_)", matcher: ")" },
  { type: "symbol_^", matcher: "^"},
  { type: "symbol_<", matcher: "<" },
  { type: "symbol_<=", matcher: "<=" },
  { type: "symbol_>", matcher: ">" },
  { type: "symbol_>=", matcher: ">=" },
  { type: "symbol_->", matcher: "->" },
  { type: "symbol_:", matcher: ":" },
  { type: "symbol_::", matcher: "::" },
  { type: "symbol_,", matcher: "," },
  { type: "symbol_{", matcher: "{" },
  { type: "symbol_}", matcher: "}" },
  { type: "symbol_$", matcher: "$" },
  { type: "symbol_.", matcher: "."},
  { type: "symbol_...", matcher: "..."},
  { type: "symbol_&&", matcher: "&&" },
  { type: "symbol_<<", matcher: "<<"},
  { type: "symbol_>>", matcher: ">>"},
  { type: "symbol_==", matcher: "==" },
  { type: "symbol_||", matcher: "||" },
  { type: "symbol_=", matcher: "="},
  { type: "symbol_!", matcher: "!" },
  { type: "symbol_!=", matcher: "!=" },
  { type: "symbol_-", matcher: "-"},
  { type: "symbol_%", matcher: "%"},
  { type: "symbol_|", matcher: "|"},
  { type: "symbol_+", matcher: "+"},
  { type: "symbol_?", matcher: "?" },
  { type: "symbol_;", matcher: ";" },
  { type: "symbol_#", matcher: "#" },
  { type: "symbol_/", matcher: "/"},
  { type: "symbol_[", matcher: "[" },
  { type: "symbol_]", matcher: "]" },
  { type: "symbol_~", matcher: "~"},

  { type: "literal_string", matcher: /^(u8|u16|u32|L)?"([^"\\]|\\.)*"([ \t\r\n]*"([^"\\]|\\.)*")*/u },
  { type: "literal_char", matcher: /^(u8|u16|u32|L)?'([^'\\]|\\.)'/u },
  { type: "literal_integer", matcher: /^(0x[0-9A-F]+(`[0-9A-F]+)*|0o[0-7]+(`[0-7]+)*|0b[01]+(`[01]+)*|[0-9]+(`[0-9]+)*)u?(c|s|i|ll|l|z|wb)?/u },
  { type: "literal_float", matcher: /^((0x[0-9A-F]+(`[0-9A-F]+)*(\.[0-9A-F]+(`[0-9A-F]+)*)?p-?[0-9]+)|(([0-9]+(`[0-9]+)*e-?[0-9]+)|((([0-9]+(`[0-9]+)*\.([0-9]+(`[0-9]+)*)?)|(([0-9]+(`[0-9]+)*)?\.[0-9]+(`[0-9]+)*))(e-?[0-9]+)?)))(f|d|l)?/u },
  { type: "literal_bool", matcher: /^true|^false/u },
  { type: "literal_null", matcher: "null" },

  { type: "identifier", matcher: /^[A-Za-z_][0-9A-Za-z_]*/u },
];
